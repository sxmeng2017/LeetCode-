这题的问题在于如何把0和非0，2和非2的部分交换
如果把非0的往前放，非2的往后放回出现问题
这里的正常解法都使用了三指针完成该任务，用左边指针控制0的存放位置，中间控制1，右边控制2
在60_13.7中，先保证了最右边一定放2，所以当中间为2时，只有last-1了，middle没有+1
这种情况下，last左边一定为0或1，此时就可以在为0时，first和middle都+1了。
如果没有保证全为0或1，即last交换的时候可能把2换了过来，first可能指向这个落后的2，导致错排，有2没有放最后

一言蔽之，middle和first都从0开始，决定了这个三指针算法能最快最好的将2放到最后，而不是把0放到最前面

如果起始条件不变，让middle在==2和==1时前进，==0时只有first前进，就会出现fisrt走的比middle快的情况，
这和first比middle慢的假设矛盾，会出现逻辑bug，将本来已经放好的数字又换到了后面去了。

也就是说first失去了本来应该作为0的存储位置的作用，，middle失去了探查新的数字的作用

指定思路时，选定三指针算法后，要明确0流向first，2流向last，middle负责探查数字，留下1.
新的数字又两个来源，一个是交换得来的新，还有就是指针前移得到的新数字。
前一个交换得来的数字，由于middle从0开始，所以==0交换得来的都是旧数字，再次确认可以省去
==2交换得来的数字需要再次确认，所以指针不迁移。
后一个得到的新数字，以指针的移动过程，进行确认。
所以问题拆为，在==2后得到新数字后，如何再次确认----》middle不移动
middle指向非等于2的数字后如何操作==0----》将0往后放----》确保first经过的位置全为0后前移，确保middle在first前面
==1---》1保留原位，确保middle在first前面

指针可用于哪些场合？
指针的特色是指针位置不动，操作指针指的值。所以对于位置确定但需要变动值的问题可以进行处理。
从以往的题目来看。位置确定指的一般是容器大小已知，变动值特指，值需要落入特定位置的场合。
